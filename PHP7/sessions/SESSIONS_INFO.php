<?php

			/*	СЕССИИ (сеансы)
					
					Сессия - это куки,живущий до закрытия браузера.
					при создании сессии создается новый куки с уникальным SID;

					Особенности:
					1) Сессия Уничтоается при зарытии окна браузера (точнее при очистке буфера, который потом наполнится)
					2) Сессия Привязана к окну браузера (в 2х окнах, открытх независимо - сессии разные)
					3) Сессии дочерних окон и рожительских связаны между собой.
    	
				// Создать сессию:

					bool session_start([ array $options = [] ])
					// Начиная с PHP7 функци принимает необязательный параметр - ассоциатвный массив с параметрами сессии

				// Уничтожить:
					$_SESSION = []; // Очистить данные сессии для текущего сценария
					@unset($_COOKIE[session_name()]); // Удалить cookie соответсвующий SID
					bool session_destroy();
				
		//-- ИМЯ СЕССИИ
				Проблема пересечения имен (возможно, что неправильно понял):
					Пусть имеются 2 скрипта, которые используют одинаковое имя переменной ($_SESSION['count'])
					Пользоватль при запуске сначала первого, потом второго скрипта, пперемешает этот count;

					Чтобы исправить жту проблему следует исп группу сессий(в док-ции протсо имя сессии - что странно)
					Так, пусть скрипт 1 исп имя группы sesA, а 2 sesB.

					Установка имени:
						Имя группы сессии по своему существу - это имя cookie (поэтому можно авторизовать 2 и более сессии)
						При этом установка cookie, совпадающего с именем группы сессии приведет к 'затиранию' того куки.

					// Установит и возвратит имя группы сессии, которая будет исп PHP для хран зарег переменных.
					// Если параметр указан, имя группы изменится на newname и вернется предыдущее имя
					string session_name([string $newname]);

					!!! session_name лишь меняет имя текущей группы и сессии, но не создает новыую сессию и времен хранилище.
					!!! Потому в большинстве случаем слудует вызывать session_name(имя группы), до инициализации session_start
					!!! Если ничего не указано, то по умолчанию PHP установит: PHPSESSID (зиенить в php.ini session.name)

					!!! Рекомендуется не мянять имя группы, следует хранить данные в подмассивах:
							Система Управления: 	$_SESSION['forum_subsystem']
							Система Авторизации: 	$_SESSION['auth_subsystem']
					P.S Вообще, чем меньше данных в массиве count($_SESSION), тем лучше, поэтому исп подмассивы...

							Пример (Ршение проблемы пересечения данных):
							// Создадим переменную для более удобного доступа
								$forum_session 	=& $_SESSION['forurn_subsystem']; 
								$auth_session 	=& $_SESSION['auth_subsystem'];

								$forurn_session['count'] = $forum_session['count'] + 1; 
								$auth_session['count'] = $auth_session['count'] + 1;
								$auth_session['is_authorized'] = true;
		
			//-- ID СЕССИИ
						SID - Имя временног хранилища, которое исп ля щапоминания данных сессии между запусками сценрия.
						
						SID относится к Группе сессии так: Имя - собирательное название для нескольких сессий (для многих SID).
								Один клиент - один SID в пределах имени группы.
								При этом Браузер работает с несколькими SID расположенными в разных пространсвах имен.

					Установка id:
						Вернет текущйи ID, sid задаст новый id сессии (не рекомендуется делать).
						string session_id([string $sid])

						Так, мы можем подклчаться к любой(даже чужой) сессии, зная id (ЕСЛИ ВЫЗВАТЬ ДО session_start)

			//--

					Чтобы не возиться с группами сессий, мы можем учтановить другой путь к  временному каталогу в который 
					PHP складывает файлы - хранилища сессий. (Т.е Сессии, используемые одной группой скриптов не будут пересекаться с другими)
					
					// Вернет имя каталога в который будут помещаться файлы - временные зранилща данных сессии. 
					// При указании каталога, изменит путь на $path (вернет предыдущий каталог)
					string session_save_path([string $path]);
			*/

			/*	ОБРАБОТЧИКИ
				
				Функция регистрации бработчиков:
				// Регистрирует процедуры, имена которых переданы в ее параметрах как обработчиии текущей сессии
				// Где $read,$write - при тении/записи в хранилище
				!!! Вызывается ДО инициализации сессии
				void session_set_save_handler($open, $close, $read, $write, $destroy, $gc) 

				PHP вызывает 6 функций связанных с обработкой сессии:

				 1)bool handler_open(string $save_path, string $session_name) // (при session_start)
				 2)bool handler_close()  // Когда данные уже записаны во врменное хранилище и его следует закрыть
				 3)string handler_read(string $sid) // При чтени данных из хранилища сессии с id $sid
				 		Вернет данные в спец формате:
				 		имя1=значени1;имя2=значение2;  
						имя - имя очередной переменной сессии
						значение - результат функции serialize() для значения этой переменной
				 		(foo|i:1;count|i:10); // временное хранилище имеет 2 переменные с значениями 1 и 10
				 4)string handler_write(string $sid, string $data) // запись данных сессии sid во врменное хранилище
				 		которое было открыто ранее обработчиком handler_open();
				 		Параметр data заается в формате (имя1=значени1;имя2=значение2;) 
				 5)bool handler_destroy{string $sid) // При уничтожени сессии с id=sid
				 6)bool handler_gc(int $maxlifetime) // Время(сек) после завершения сесси после которого нужно собрать мусор(garbage collection)
								Сбор мусора ресуркоемкая операции, поэтому 
								вызывается эта функции не всегда а иногда с вероятностью(%) при запуске равной session.gc_probability (В конфиге)

			
				

			*/
?>