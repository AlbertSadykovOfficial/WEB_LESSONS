<?php 		// ОШИБКИ
				
			/*	Виды Ошибок:
				1) Ошибочная ситуация (при ошибке синтаксиса)
				2) Внутренняя ошибка (Неверные действия программы (открытие несуществующего файла))
				3) Пользоваелская ошибка (Не правильно ввел пароль)
			*/



			/*
				Если в программе возникла ошибочная ситуация нужно реить что делать.
				Код, который жим занимается назвается Кодом восстановления после ошибки.
				Запуск этого кода назвается восстановление после ошибки.

				Пример:
				$f = @fopen("spoon. txt", "r") ;   // @ - Говорит PHP, Что не надо в браузер выводить сообщение, мы его написали сами
				if (!$f) return; 
			*/

			/* Контроль ошибок

				Уровнем детализации сообщений управляют следующие дериктивы:
				
		//--Установка уровня строгости для контроля ошибок php
				error_reporting 
					Возможные значения - числовая константа (E_ALL ~ E_NOTICE) (~ - Оператор Искл ИЛИ)
					Устанавливаются в php.ini, .htaccess, ini_set();
					+ Интересная константа: E_STRICT (рекомендации PHP по улучшению кода) 
																	E_DEPRECATED -Узнать устаревшие констуркции
					Ставь E_ALL, чтобы узнать свою тупость, это ок, если ошибок очень много
					Рекомендуется в php.ini использовать E_ALL, при нужде отключать ее в скрипте К примеру: error_reporting (E_ALL- E_NOTICE); 
		
		//--Вывод сообщений в бразуер пользователя
				display_errors
				log_errors
					Возможные значения off и on
					Устанавливаются в php.ini, .htaccess, ini_set();

					+Рекомендуется исп при отладке скриптов(display), в рабочем варианте: log_errors
		
		//--Задать путь к журналу
				error_log
					Возможные значения : Абсолютный путь к файлу (по умолчаию не задан)
					Устанавливаются в php.ini, .htaccess, ini_set();
				

		//--Оператор отключения ошибок (@) (Блокирует и log в файл) (Функция после @ при этом выполняется)
				Может хорошо помочь, например, при обновлении старых файлов.
				Так, обычно чтобы обновить файл нужно сначала проверить его существование, потом время:
					if (!file_exists ($fname) || filemtime ($name) < time()-60*60) 
				С @:
				if (@filemtime ($fname)<time () -60*60) // @ проверит существование файла за счет ошибки
				
				Пример:
					Проверить нажата ли кнопка submit при отправке формы:
					if (@$_REQUEST['submit']) echo "Кнопка Нажата" 

			-	Стоит аккуратно использовать @, это может навредить, поэтому:
					1)Не подавлять сообщения включаемх файлов(больщих фрагментов программы)!
						@include "mistake.php"; 
					2)Не подавлять сообщения функций в которых не уверены на 100%
						@myOwnBigFunction(); 
				
			+	Когда стоит использовать:
					1) Проверка существования/несущ элемента массива
						if (@$_REQUEST['submit'])
					2) Перед стандартными функциями:
							fopen(), filetime(), mesql_connect()
					3) 


			*/

		/*  Установка параметров из приложения
				// Параметр name в значение value
				string ini_set(string $name, string $value) 
		*/

		/*	Перехват ошибок
				
				// Регистрация пользовательского обработчика ошибок, указанных битововй маской Пример(E_ALL ~ E_NOTICE)
				// Функция вернет имя предидущего обработчика, если он был
				string set_error_handler(string $funcName [, int $errorTypes])

				Пример:
				// Так перехватятся не все ошибки (Ошибки E_ERROR, E_PARSE и функции die() exit() не перехватываются)
				// Их дополнительно можно перехватить в перехватчике выхожного потока ob_start(), $msg и $errnum считываются с конца строки
				// + В случае, если ошибка вернет false, считается, что она не обработана и обработаестя стандартным обработчиком
				<?php
					function myErrorHandler($errno, $msg, $file, $line)
					{
						echo '<div style="border-style:inset; border-width:2">'; 
						echo "Код ошибки: $errno <br>";
						echo "Файл: <tt>$file</tt>, Строка $line.<br />"; 
						echo "Текст ошибки : $msg";
						echo "</div>";
					}

					set_error_handler("myErrorHandler", E_ALL);
					// Провокация на несуществующий файл + его перехват @
					@filemtime("spoon");
				?>

				//Когда исп set_error... Предыдущее имя пользовательской функции запоминается в специальном внутреннем стеке.
				//Чтобы извлечь это имя из стека и установить его в качетве обработчика
				// Необходимо следить, чтобы кол-во вызовов restore_error_handler было равно set_error_handler
				void restore_error_handler()
		*/


		/* Генрация Ошибок
				
				// Генерация ошибок пользовательского уровня (Если задан этот уровень, вернет False, иначе TRUE)
				// ВТОРОЙ ПАРАМЕТР ЗАДАЕТ УРОВЕНЬ ОШИБКИ
				bool trigger_error(string $error_msg [, int $error_type =  E_USER_NOTICE]);

				Пример:
					if( age < 0)
						trigger_error("print_age() : eospacT He Mo~eT Ob!TbOTPl1UaTenbHb1M", E_USER_ERROR);
					
					print_age(-12);

				
				// записывает $msg в файл журнала
				error_log(string $msg [,int $type] [,string $dast] [,string $exrtra_headers]) 
						$type == 0 Запистаь в системный фалй журнала или в файл аданные в дерективе error_log
						$type == 1 Отправляет сообщение по посте адрессату, чей адрес указан в dest, $extra_headers исп в качетсве доп почт. заголовков
						$type == 2 сообщение добавляется в конец файла с именем $dest

		*/

		/*  Просмотр Стека вызовов функций:
				list debug_backtrace()
				
				print_r(debug_backtrace());

		*/


		/*	Исключения 
				
				Конструкция 	throw умеет раскручивать стек. Если она будет использована внутри функции,
				которая была вызвана в try, то она пойдет наверх до try и потом пойдет в catch
				
				try
				{
					echo "Bсе, что имеет начало <br>"; 
					// Возбуждение ошибки (После этой строчки блок try прекратит работу)
					throw new Exception("Hello!"); 

					echo "Имеет и конец"; 

				} finally
				{
					echo 'Выполнится в любом случае';
				}	
				catch (Exception $e)
				{
						echo {$e->getMessage()}
				}
				echo "Конец программы"
				
				// Конструкции finally и Exception всегда выполнятся (Т.к)класс Exception вкл в себя все ошибки, finally спец функция
				
				Пример:

				Корректное уничтожение всех обьекто, созданных до try
				<?php 
						
						class Orator
						{
							private $name; 
							function __construct($name) {	$this->name = $name; }
							function __destruct()				{	echo "Уничтожен обьект {$this->name}.<br />"; }

							function outer () { $obj= new Orator(__METHOD__); inner(); }
							function inner()
							{
								$obj = new Orator(__METHOD__); 
								echo 'Выбрасывание';
								throw new Exception("Hello!");
							} 
						}
						
						echo 'start';
						try
						{
							outer(); 
							echo "Сюда не попадет, если я правильно опнимаю";
						} catch (Exception $e)
						{ 
							echo $e->getMessage () 
						}
						echo 'finish';
				?>

		
		// КОРОЧЕ, ЮЗАЙ ЭТУ БИБЛИОТЕККУ:
		// PHP_Exceptionizer

		*/


?>