<?php
/*
		Подробная инфа в документации PERL или PHP

		Литература для более Глубоко Представления:
			Джеффри Фридла "Регулярные выражения, библиотека программиста" // "Mastering Regular Expression"

		Регулярные выражения - насилия над компьютером, их стоит применять только в нужных случаях,
		заменять что-то в строках по возможности нужно спец функциями, а не силами RegEx
	
		Есть несколько языков регулярных выражений, наиболее известные это (PCRE, POSIX...)
		Т.к POSIX считтается устаревшим, то используют  в основном 
		PCRE - Perl Compatible Regular Expression (Регулярное выражения языка Perl)


		Язык PCRE состоит из 
			*Простых символов
			*Управляющих конструкций . , *, +, ? , |, (, ), [, ], { , }, $, ^. .// $ как и в php, поэтому лучше исп 'RegE', а не "RegE"
			*Мнимых символов

		/ - начало и конец выражения, после него могут идти модификаторы (Так же могут быть и #,{},[])
		М - Модификатор
		Общий вид : /Выражение/М
								#Выражение#М
								{Выражение}М // Парные скобки позволяют писать внутрь себя такие же скобки
		 Моификаторы:
		 	/i 	-	 Игнор регистра
			/x 	-	 Пропус пробелов и комментариев $re = '{\[ (\w+)\] #Комментирую
																										}ixs'; 
			/m 	-	Многострочность (Для учета симаолов перевода строк и тд) (по умолчанию в preg_match)
						$str = preg_replace('/^/m', "\t", $strJ); // Замена начало каждой строки на символ табуляции (преписыаем в начало)
							Этот можификатор меняет некоторые значения символов:
						^ - Начало Каждой строки
						$ - позиция перед /n .(\r\n не работает, нужно предварительно удалять \r)
						. - Совпадает с любым символом за исключением \n 					
						\A - Начало Данных (альтернатива ^ без /m)
						\z - Конец данных (альтернатива $ без /m)																	
			/s 	-	Однострочный поиск (по умолчанию в preg_replace)
			/e 	-	Выполнение PHP программы при замене (только в preg_replace, со вторым параметрм функцией) (лучше исп preg_replace_callback)
						!Но код выполняется после подставления занчений $1 и $3 (Поэтому могут возникнуть проблемы с апострофами)
						Пример:
						$str = preg_replace(
															'{ (</?) (\w+) (.*?>)}es', # Находим откр или закр тег
															"'$1'.strtoupper('$2').'$3'", #Переводим в верхний регистр
															$str
															);
			/u 	-	UTF-8 (Рекомендуется включать для всех операций с русским текстом) - Перевод RegEx в режим многобайтовой кодировки
		
		Классы Символов:
			. - Один любой символ
			\s - Соотвествие символу Пробела " ", "\t","\n","\r"
			\S - Соотвествие любому символу, кроме пробела
			\w - Любая буква или цифра
			\W - Не буква и не цифра
			\d - цифра от 0 до 9
			\D - Все, что угодно, только не цифра
			[x] - любой символ x
			[a-zA-Z0-9_] - любой алфавитно-цифровой символ
			Список спец выражений
			[:alpha:] - буква
			[:digit:] - цифра
			[:alnum:] - буква или цифра
			[:space:] - пробельный символ
			[:blank:] - пробельный символ или символы с кодом от 0 до 255
			[:cnrtl:] - управл символ
			[:graph:] - символ псевдографики
			[:lower:] - символ нижнего регисра
			[:upper:] - символ верхнего регистра
			[:print:] - печатаемый символ
			[:punct:] - знак пунктуации
			[:xdigit:] - Цифра или буква от A ДО F
			Пример:
			'/abc[[:alnum:]]+/' 						| abc затем одна или более буква или цифра
			'/abc[[:alpha:][:print:]0]+/' 	| abc буква, знак пунктуации или 0
			'/abc[\w.]/' 										| abc затем любая буква или цифра, или точка (в [] точка теряет свое спец назнаение)
			'/[^<>]/'												| Любой символ кроме <> (^-отрицание, но лиь внутри [])

			!НО
			'/abc[:alnum:]+/'								| НЕ ПАШЕТ 

		Квантификаторы (уточнение действий):
			* - 0 и более повторений (склонна к жадности (поглащает как можно больше символов))
			+ - 1 и более сопадений Пример:  /[a-zA-Z]+-[a-zA-Z]+/.  // Есть ли в троке слово написанрное на анг через дефис
			? - 0 или 1 раз /[a-zA-Z]+\r?\n/  - Определение того, что последнее слово приато к правому краю строки в WIN
			{}- X{n,m} - Символ может быть повторен от n о m раз (n,m - int(до 65k))
					X{n} 	 - Символ может быть повторен n раз
					X{n,}  - Символ может быть повторен n и более раз
		
		"Жадность квантификаторв"
		$str = "Hello, this <b>word</b> is <b>bold</b>!";
		$re= '|<(\w+) [^>]* > (.*) </\1>|xs'; 
		preg_match($re, Sstr, $matches) or die("HeT Teroe.");
		echo htmlspecialchars("'$matches[2]' oOpaMJJeHo TeI'OM '$matches[1] '"); // 'word</b> is <b>bold' Обрамлено тегом 'b'
		--> Квантификатор ищет не первый попавшийся </b>, а самый последний
		--> Чтобы убавить его аппетит нужно поставить ? после любого из квантификаторв *,+,{},?
				preg_replace('/<.+?>/s', '', $str);
				Замена [b][/b] на <b></b>
				preg_replace('|\[b\] {.*?} \[/b\]|ixs', '<b>$1</b>', $str);  
		!!! Но ленивое выражение тоже не решение проблем оно будет искать 1 сопоставление 
				'[b] Жирный текст [b] Тут еще жирнее [/b] Вернулось[/b]' // Ленивое остановится на первой [/b], а жадное не учтет все внутри
		
		--> REGULAR EXPRESSION Не в сила работать со вложенными констукциями, поэтому своии ручками все пишем

		Мнимые символы
			^ - Начало строки (не первому символу, а перед ним)
			$ - Конец строки (за посленим символом)
			\b- Начало или конец слова
			\B-Любая позиция кроме начала или конца слова
			
			Пример:
			/^$/s  - Пустая строка (Сразу после начала идет конец);

		Операторы Альтернативы (|)
		/\.gif$|\.jpe?g$/

		Группировка (работают как скобки, при выносе за них применяются ко всему, что внутри)
		' #^(\w:|\\\\|/) # ' /// Путь через диск C:\\

		Выделенее даты 
		 | ^\s* ( (\d+) \s*[[:punct:]]\s* (\d+) \s*[[:punct:]]\s* (\d+) ) \s*$|xs // запишется в [0] дата, затем день[1],месяц[2], год[3]
		


		 Про слеши (Синдром зубочиски :)):
		 	В PCRE \ нужно экранировать \\, в php Это тоже надо делть, поэтому:
		 	Найдем, к примеру Имя файла в WIN предваренное обратним слэшем:
		 	$re= '/\\\\filename/';
		 	Любое имя катлога, после которого идет любое имя файла:
		 	$re= '/\\S+\\\\\\S+/'; 

			Помотреть как видит PCRE выражение
		 	echo "<tt>".htmlspecialchars($re) ."</tt>"; 

		 	Пример:
		 		Чтобы в строку вставить рег выраение со * нужно его предворить \, т.к это спец символ, но php воспримет это как свой спец символ (1) поэтму нужно писать так (2):
		 		(1) $re = "/a\*b/" 
		 		(2) $re = "/a\\*b/";

			
			Незахватывающий поиск
			В PCRE существует ряд конструкций, способных сравниь строки без завата, но так как
			эти конструкции имеют 0 ширину совпадения, то в кармане окажется строка нудевой длины
				Позитивный Просмотр ВПЕРЕД:
				(?=подвыражение) (может быть полноценное RegEx)
				 |(\S+) (?=\s*</) |. // Слово после которого идет закнрывающийся тег (сам тег не войдет, как и промежуточные пробелы)

				Негативный просмотр ВПЕРЕД:
				(?!подвыражение)
					/
						(?! [.,]) 				# Дальше Не точка и НЕ запятая 
						([[:: punct::]]+) # А знак пунктуации
					/x

		??	Позитивный Просмотр НАЗАД: (желателно фиксированной длины, либо представлять альтернативу тоже фиксированной длинны)
				(?<=подвыражение)
					/
					  (?<=<)		# - Слева начало Тега
					  (\w+)			# - Затем имя Тега
					/
				Негативный просмотр НАЗАД:
				(?<!подвыражение)
				 /( ?<!foo) bar/   boobar - true, foobar - false




//--Найти (Сопоставление):
		
		1 - Удачно // по умолчанию работает в режиме /m
		Ищет 1 попавшийся элемент
		bool preg_match(
									string $pattern,
									string $subject
									[, array &$matches]
									[, int $flags = 0]		// PREG_OFFSET_CAPTURE -Делаетмассив и сохраняет текст в [0], а позицию совпадения в [1]
									[, int $offset = 0])  // Позиция начала строки
			matches хранит отдельные участки совпадения в matches[0] всегда подтрока совпадения целиком

		Пример (Найти email в тексте):
				\S         - Не пробел
				[a-z0-9.]+ - Любое число Букв, Цифр, Точек
				i + s - Однострочный режим (модификатор i - не учитывает регистр)

			preg_match('/(\S+)@([a-z0-9.]+)/is', 'Привет от  somebody@mail.ru!', $m);
			
			// Имя хоста будет в $m[2], a имя ящика (до @) в $m[l].
			echo "В тексте найдено, Ящик: $m[l], XOCT - $m[2]"; 

			Пример (Найти элемент который обрамен либо <pre> либо <b> и запомнить его):
			Имя тега в 1 кармане, содержимое во 2
			/<(\w+) [^>]* > (.*?) </\1>/xs  /// .*? - НАЙТИ минимальную строку
			Принцип: нахожит открывающийся тег, записывает его значение в 1 карман, при нахождении закрыв. тэга, сопоставл его с 1 карманом
			Карманы нумеруются и записываются последовательно начиная с 1 номера (все, что в круглых скобках)
			Чтобы исключить такой карман из массива нужно поставиь :? после скобки т.е. (:?....)

			ИМЯ Кармана : (?<name>) или (?'name')
			$re = "|^(?<year>\d{4})-(?<month>\d(2J)-(?'day'\d{2})$|";
			echo "day: " $matches['day'] "<br />"; 
		
			Вернет число найденных строк
			int preg_match_all(
									string $pattern,
									string $subject,
									array &$matches
									[, int $flags = PREG_PATTERN_ORDER]
									[, int $offset = 0])  // Позиция начала строки

					$flags:
					PREG_PATTERN_ORDER   -  $matches[B][N] - [B] порядок открывающейся скобки, [N] -номер совпадения(если несколько) 
					PREG_SET_ORDER 			 -	Сортировка по номеру совпадения (структура будет как и в preg_match) 
																	$matches [N][B] [N] - Порядковый номер совпадения, [B] - номер скобки
					+PREG_OFFSET_CAPTURE -	Прибовляется Заставляет возвращать цифровые значения вмест с элементами(как preg_match)
			Пример рабоыт PREG_SET_ORDER
			$re = '|<(\w+) .*?>(.*?)</\1>|s'; 
			$text = "<b>Текст</b> и еще <i>другой текст</i>"; 
			Ответ:
			Array(
						[0] => Array( 
												[0] - <b>Текст</b>
												[1] - b
												[2] - Текст
												)
						[1] => Array( 
												[0] - <i>другой текст</i>
												[1] - i
												[2] - другой текст
												)
						)

//--Заменить

			Ищет в $subject pattern и заменяет на replacement // по умолчанию работает в режиме /s
			Вернет результат работы
			mixed говорит о том, что это можгут быть списки строк
			Если, к примеру, в subkect передать списко строк, то он заменить там все по порядку
			Если replacement тоже список, то он ПОПАРНО заменяет все pattern'ы $pattern[$i]=>replacement[$i], 
			если replacement короче, чем pattern, то произойдет замена пустой строкой
				string preg_replace(
													mixed $pattern,
													mixed $replacement,
													mixed $subject,
													[, int $limit = -1]		// Будет произведено не более $limit поисков и замен
													[, int &$count]) 			// вОЗВРАЩЕТ КОЛИЧЕСТВО ФАКТИЧЕСКИХ ЗАМЕН
				!!! $0 \0, $1 \1 Интерполируются - заменит совпадение 0 УРОВНЯ целиком, 1 УРОВНЯ первая откр скобка

				Пример (Заменить все email на их ссылки)

					$text= "Привет от somebody@mail.ru, a так же от other@mail.ru!"; 
					$html = preg_replace(
																'/(\S+)@([a-z0-9.]+)/is',		 // Паттерн 
																'<a href="mailto:$O">$O<la>',// Заменить на это
																$text 											 // В этом тексте
																);
				Пример (Удаление тегов для XML файлов) 
					 preg_replace('/<[^>]+>/','', $text) ; // В html может быть <img alt="a>b">, что приведет к ошибке

				Пример Кармана (выделние имени)
				$text = htmlspecialchars(file_qet_contents(_FILE_)) ;
				$html= preg_replace('/(\$[a-z]\w*)/is', '<b>$1</b>', $text1; ); // подставляем содержимое камана 1
		
			Устранение проблемы замены PHP кодом /e
			Процедура передает значение карманов в $callback, возвращенный результат исп для подстановки
			mixed preg_replace_callback(
																mixed $pattern,
																callable $callback,
																mixed $subject
																[, int $limit = -1]
																[, int &$count]
																)
				Пример (перевод всех текгов HTML в верхний регистр):
					$str = '<hTmL><body> style="background: white;">Hello world'</body></html>';
					$str = preg_replace_callback(
																	' { (?<btag></?) (?<content>\w+) (?<etag>. *?>)}s',
																	function ($m) { return $m['btag'] .strtoupper($m['content']) .$m['etag']; ),
																	$str);  
					echo htmlspecialchars($str);  // <HTML><BODY bgcolor="white">Hello world!</BODY></HTML> 

				В PHP 7 есть еще 1 функция:
				mixed preg_replace_callback_array(
																array $patterns_and_callbacks,
																mixed $subject  // Может быть и массив строк
																[, int $limit = -1]
																[, int &$count]
																)
				$patterns_and_callbacks - ассоциативный массив в качестве ключей - регулярные выражения, а значений - callback функции
				Как ожно применять: 
				 1) Сначала поднять все  теги в верхний регистр, потом содержимое (x) тега заключить в <strong>
				 2) Автоматическое подставление у <img> width и height  в результате перехвата выхожного потока скрипа (ob_start())
				 3) Умная замена псевдотегов с параметрами [fontsize = 10] (в форумах и остевых книках)
				 4) Подстановка PHP кода в шаблонах
				 		... 

//--	Разбиение по ругулярному выражению	
			
			Разбивает строку на чати, делая это по регулярному выражению (как explode(), но медленнее, но имеет больше возможностелй)
				list preg_split(string $expr,
												string $str 
												[,int $limit = -1] 
												[,int $flags = 0]) 
					flags :
						PREG_SPLIT_NO_EMPTY - Из результирующего списка будут удалены элементы равные пустой строке
						PREG_SPLIT_DELIM_CAPTURE - В списко помимо участков строк между будут включены и сами совпадения
						PREG_SPLIT_OFFSET_CAPTURE - Вернет массив списков (пара = подстрока=>позиция), позиция - смещение от начала $str

			Пример (выделение уникальных слов в тексте) 
			Может пригодиться для написание индексирующей поисковой системы на PHP
				
			<?php
						//Ф-ция выделяет из текста $text Все уникальные слова и
						//Возвращает их список
						//В необяз nOrigWords помещается исх число слов в тексте
						//которое было до фильтрации дубликатов

						function getUniques($text, &$nOrigWords =false)
						{
							// Все слов в тексте
							$words = preg_split ("|([^[:alnum:]| ['-])+/s", $text); 
							$nOrigWords = count($words); 
							
							// Слова в нижний регистр
							$words = array_map( "strtolower", $words); 
							

							// Получаем Уникальные значения
							$words= array_unique($words);
							return $words; 
						}

						setlocale(LC_ALL, 'ru_RU.UTF-8'); 
						$fname = "largetextfile.txt"; 
						$text = file_get_contents($fnarne); 
						$uniq = getUniques($text, $nOrig); 

						echo "Было слов: $nOrig<br />"
						echo "Стало слов:".count($uniq)."<br />";
						echo join(" ", $uniq);  

				//  В тексте на англ 55кБ  (Будет время надо попробовать написать 'архиватор', который заменяет слова на числа)
				// Было слов: 10342
				// Стало слов: 1620
						
			?>

//--	Экранирование спец символов (если, кпримеру, идет енерация RegEx)
			
			Функция экранирование символов* в строке 
			символы* . \ + * ? [ ^ ] $ {} () = ! < > | : -  // Тут нет (/)
			$bound - Дополнительный смвол экранирования // Обычно исп это для символа (/)
			string preg_quote (string $str [,string $bound = NULL]) 

			Пример:
				Пусть имеется фраза, которую нужно выдлить в html.
				Но во фразе могут присутвовать спец символы или разные пробелы, так:
				<?php
						// Сначала экранируем все спецсимволы
						$re = preg_quote($highlight, "/"); 

						// Меняем пробельные символы на (\s+) - любые пробелы
						$re = preg_replace('/\s+/', '\\s+', $re); 

						// Подчеркиваем слово
						echo preg_replace("/($re)/s", '<b>$1</b>', $text); 
				?>
	
//-- Фильтрация Массива			
			
			Вернет строки из массива input, которые совпали с RegEx (ключи массива охраняются)
			flag может принять одно значение PREG_GREP_INVERT  (Вернет несовпавшие строки)

			array preg_grep(string $expr, array $input [, int $flags = 0]) 

			Пример (Распечатать имена файлов в текущем каталоге имеющего шаблон ex + цифра)
			<?php 
				foreach (preg_grep('/^ex\d/s', glog("*")) as $fn)
				echo "Файл Примера: $fn<br />"; 
			?>
*/
?>

<?php  // ПОЛЕЗНЫЕ ПРИМЕРЫ ?>

<?php 
				// Замена всех email в тексте на их ссылки (Не для всех, но для большинства)
		$text = "Адреса:  user-first@mail.ru, second.user@mail.ru.";
		$html = preg_replace( 
			'{
					[\w-.]+ 						# Имя ящика
					@
					[\w-]+(\.[\w-]+)*  	# Имя Хоста

			}xs', 
			'<a href="mailto:$0">$0</a>',
			$text
		);
		echo "html";

?>

<?php
				// АКТИВИЗАЦИЯ HTML ССЫЛОК

					// ЗАМЕНА (протокол://URL) на ссылку
					// Протокол: ftp, http
					// URL - какой-нибудь адресс

		function hrefActivate($text)
		{
				return preg_replace_callback(

								'{
									(?:
											(\w+://)				# Протокол с 2 слешами
											|								# Или
											www\. 					# Начинается с www
									)
									[\w-]+(\.[\w-]+)* 	# Имя хоста
									(?: : \d+)? 				# Порт (необязателен)
									[^<>"\'()\[\]\s]* 	# URI (без кавычек и скобок)
									(?: 								# Последний символ должен быть:
										(?<![[: punct:]])   # Не пунктуационным
										| (?<=[-/&+*] 			# Но допустимо окончаниена -/&+*
									)




								}xis',
								function ($p)
								{	
									// Преобразуем спец символы в html представление
									$name = htmlspecialchars($p[0]);
									
									// Если нет протокола, добавляем его в начало строки
									$href = !empty($p[l])? $name: "http://$name"; 

									// Формируем ссылку
									return "<a href=\"$href\">$name<la>";
								},
								$text
								);
		}
?>