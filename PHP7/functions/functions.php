<?php 

/* --------- Моментальный сброс буфера echo
		При использовании echo php накапливает его содержимое в буфере, чтобы пото транспортировать
		'большой пачкой' (так быстрее), данная функция позволит досрочно вывести данные (при выводе
		в реальном времени) - к примеру, чаты.
		void flush() 
*/
/*				
	// ----------- Строковые
	 PHP основан на ASCII коде, его ядол не понимает UTF-8;
	 chr(symb)  - Узнать номер символа;
	 ord ();   	-	Узнать символ по номеру;

	 echo "\u{0410};"  // Вывод символа UTF-8 русской А

	 // Языкначал разрабатываться до перезода всех на  UTF-8
	 // В нем анг буквы кодируются 1 Байтом, а Русские - 2 Байтами
	 // Так, при обращени к символу l мы поучим l, а к и -> ромб
			echo "{l}";  // l
			echo "{и}";  // Ромб

	 	strlen('Привет, мир!')		 - Обычный подсчет //21 байт (3 на знаки и 18 на буквы 9*2)
		mb_strlen ('Привет, мир!') - Подсчет символов с учетом многобайтовости. //12
		// При значении  mbstring. func_overload = 2 в php.ini strlen будет работать нормально, но некоторые
		// прилоожения могут работать некорректно: Bitrix, phpMyAdmin...
	
		pass = string trim (string $st [, strinq $charlist)) - Обрезает лишнее 
		string ltrim (string $st [ , string $charlist] )     - Обрезает ведущие пробелы
		string chop (string $.st [ , strinq $charlist]) 		 - Обрезает концевые пробелы
		($charlist- Кастомный набор символов, подлежащих удалению)

		int strpos(string $where, string $what [, int $from =0]) - Поиск $what в $where - вернет 1й символ 
		int strrpos(string $where, char $what [, int $from =0])  - Верепт последний символ

		int strcmp(string $strl, string $str2)  - 0 если равны, -1 если str1<str2 при одинаковой длине
		int strcasecmp(string $strl, string $str2) - НЕ учитывает регистр букв при сравнении
		Альтернатива : <=> (PHP7)


		string substr(string $str, int $start [,int $length]) - Возвращает строку с позиции start длины length
		
--- ЗАМЕНА (Лучше,чем preg_replace)в text строки from  на to. count записывает число произведенных замен

		string str_replace($from, $to, mixed $text [, int &$count]); В text можно преедавать массив строк,а не ону строку
		string str_ireplace($from, $to, mixed $text [, int &$count]); Без учета регистра
		string substr_replace(string $text, string $to, int $start (,int $len]) Замена участка со start длинны len на to
		---> $from  и $to могут быть и массивами, тогда будет заменяться в text from[i] на to[i]	
		
		Схожа с str_replace, но при замене не проходит по одному и тому же ключу 2 раз как str_replace
		strtr никогда не сделает замену после предыдущей итерации

		string strtr(string $str, string $from, string $to) 
		string strtr(string $str, array $subatitutes) 
		
		! Не совместима с UTF-8 ---> Работает тольк с однобайтовыми кодировками
		Пример:

		<?php # Транслитирация строк
				function transliterate($st){ 
					$st = strtr($st, "", // массив русских букв
														""); // массив букв не подлежащих особой транлитерации
				
					$st = strtr($st, array( 'e'=>"yo", 'щ' =>"shch", 'E'=>"Yo", '111' =>"Shch", ) ) ;
					return $st; 
					} 
					echo transliterate("У попа была собака, он ee любил"); // U popa byla sobaka, on ee lyubil
		 ?>
 */

/* --------- ПРЕОБРАЗОВАНИЕ СИМВОЛОВ
	
	Кодирование
		string urlencode(string $st);
		string rawurlencode(string $st); // То же, что и urlencode, но ' ' не пеобразуется в +
	 Например, нужно сформировать url запрос с какими-то символами (=,' ',!):
	 echo "<a href='/script.php?param=".urlencode($userData)."'>Ссылка</a>"; 
	
	Декодирование (PHP и сам умеет, но все же)
		string urldecode(string $st);
		string rawurldecode(string $st); // не воспринмает + как пробел
		
	Замена тегов 
		string htmlspecialchars(string $st [,int $flags = ENT_COMPAT | ENT_HTML401[,strinq $encoding = ini_get("default_charset")[,bool $double_encode = true]]]); 
		
		2)Константы (остальные смотри в документации - задаются побитовым сдвигом)
		ENT_COMPAT - (') в &quot, (") без изменений
		ENT_QUOTES - (') в &quot, (") в &#039;
		ENT_NOQUOTES - (') и (") - без изменений

		3)$encoding - принимает строку с названием кодировки (С PHP 5.4 по-умолчанию UTF-8)
			С PHP 5.6 конфиг моно задать через php.ini, импользуя дериктиву default_charset
		4)$double_encode - режим повторного кодирования html-тегов. 
			Работает так: если видит &quot, прописывает &quot;&quot;
			По-умолчанию true, для отключения -> false;

	Вставка слешов перед  (', " и \)
		addslashes(string $st) 	
	
	Замена \\ -> \ из списка выше
	 stripslashes (string $st) 
*/

/* --------- Изменение Регистра (С Кириллицей возможны проблемы)
		
		strtolower(string $st);
		strtoupper(string $st);

		ucfirst(string $st); // Первую букву в верхний регистр

*/

/* --------- Установка Локальных Настроек
		
		string setlocale(int $category, string $locale); 
		
		Устанавливает текущую $locale с которой будут работать функции категории $category:
		
		LC_CTYPE - активизирует local для ф-ций перевода в регистры
		LC_NUMERIC - для ф-ций форматрования дробных чисел (задает разеоитель целой и дробной части в числах)
		LC_TIME - задает формат вывода даты и времени по умолчанию
		LC_ALL -	устанавливает все вышепречисленные режимы

		!!! Имена locale не имеют стандартов и могу отличаться от срвера к серверу, при установки таковых следует обратиться к провайдеру.(Узнать как назваются locale для разных кодирвок). locale могут отличаться для разных ОС, с эти также надо быть начеку.
		!!! По умолчанию PHP не использует никакую locale, их нужно подключать самому, без них некоторые функции могут работать неправильно (strtoupper(), strftime ())
		Для подключения вначале кода следует подключить:
		setlocale(LC_ALL, ''); // Так PHP ам выберет переменную,установленную в системе по умаолчанию (в UNIX ЗНАЧЕНИЕ 												 //	ХРАНИТЬСЯ В ПЕРЕМЕННОЙ LANG)
		При установке:
			'' - Установится та локаль,к отора присутствут в глобальной переменной окружения имен, совпад с именем 						 $category (или LANG)
			0 - локаль не установится, а вернет значение текущей локали для указанного режима.

		Пример:
		setlocale(LC_CTYPE, 'ru_RU.UTF-8');  // Замена регистра букв в соответсвии с UTF-8
*/

/* --------- Форматные Преобразвания	
	Строка с отформатирваннымичислами
		sprintf (strinq $format [,mixed args, ... ])  
		
		$format может вклюать в себя команды форматирвоания, предваренные символом ( % );
		Все остальные символы копируюся в предваренную строку.
		Для того, чтобы поместить симовл ( % ) в строку, его следует удвоить(%%):
		echo sprintf("The percentage was %d%%", $percentage);

		Каждый спецификатор формата включает в себя 5 эементов (слитно) :
		% Заполнитель [-] Размер .Точность Тип
			-Необязательные:
				Заполнитель - символ, который выводится,если выводимая величина занимает МЕНЬШЕ ЗНАКОМЕСТ
				[-] - спецификатор выравнивания (- левое выравнивание), по умолчанию правое
				размер - поле для вывода величины
				.точность - кол-во знаков после запятой в результирующей строке (игнорируется, если число не с плав. точкой)
			+Обязательный:
				тип - Спецификатор типа величичны, которая будет помещеня в выходную строку
				•	b -	очередной док из списка выводится как двоичное целое число 
				•	c - выводится символ с указанным в аргументе кодом
				•	d - целое число; 
				•	f - Число с плавающей точкой; 
				• o -	восьмеричное число; 
				• s - строка символов; 
				• x - шестнадцатеричное цулое число с маленькии буквами a-f; 
				• X - шестнадцатеричное цулое число с большими буквами  A-F. 

			Пример 1:
				$moneyl = 68.75; 
				$money2 = 54.35; 
				$money = $moneyl + $money2;
				echo "$money<br>"; 									 	// "123.1" 
				echo sprintf ("%01.2f<br>", $money); // "123.10"
			
			Пример 2:	
				$isodate = sprintf("%04d-%02d-%02d", $year, $month, $day); 
			
			Еще есть с разелением на 3 знака, но так впадлу было писать.
*/

/* ----- Работа с БИНАРНЫМИ данными
		
	Упаковка аргуменов в бинарную строку, которая потом и возвращается
		string pack(string $format [, mixed $args, ...]); 
			$format - набор однобуквенныхспецификаторов( задает формат и количество )
			•	a - Строка, свободные еста заполняются символом 0; 
			• A - Строка, свободные еста заполняются Прбелами; 
			• h - Шестнадцетеричная строка, младшие символы вначале; 
			• H - Шестнадцетеричная строка, старшие символы вначале;  
			• c - знаковый 		байт (символ); 
			• C - беззнаковый байт; 
			• s - знаковое короткое целое ( 16 битное, порядок байтов определяется архитектурой процессора); 
			• s - беззнаковое коротокое целое; 
			• n - беззнаковое целое ( 16 битов, Старшие разряды в конце); 
			• v - беззнаковое целое ( 16 битов, Младшие разряды в конце ); 
			• i - знаковое целое (размр и порядок байтов определяется архитектурой процессора); 
			• r - беззнаковое целое; 
			• l - знаковое длинное целое;  (32 бита, порядок байтов определяется архитектурой процессора; 
			• L - беззнаковое длинное целое; 
			• N - беззнаковое длинное целое; 32 бита, Старшие разряды в конце); 
			• v - 6e33HaKOBOe uenoe (32 бита, Младшие разряды в конце ); 
			• f - число с плавающей точкой (определяется архитектурой процессора); 
			• d - число с плавающей точкой двойной точности(определяется архитектурой процессора); 
			•	x - символ с нудевым кодом
			• x - Возврат назад на 1 Байт; 
			• @- Заполнение нулевым кодом до хаданнойабсолютной позиции.

		Пример:
		Целое, целое, все остальное - символы
			$bindata = pack("nvc*", Oxl234, Ox5678, 65, 66); 
		Результат:
		В строке 6 байтов :  0x12, 0x34, 0x78, 0x56, 0x41, 0x42  (16-система)
		
	Распаковка data, исзодя из format 
		array unpack(string $format, string $data); 
	
		Возвращает ассоциативный массив, содержащий элементы распакованных данных.
		Строка format задется в следующем формате:
		 После каждого спецификатора должно впритык слеовать имя ключа в ассоциативном массиве.
		 $array = unpack("c2chars/nint", $bindata); 

		 В результирующий массив будут записаны данные  с ключами charsl, chars2 и int
		 Так как после спецификатора задано число, то к имени ключа будут добавлены номера 1,2,...
		 --> в массиве будут ключи, отличающиеся суффиксами
	
	! В PHP достаточно фукций для работы с бинарными файлами, представленные выше будут нужны очень редко
*/