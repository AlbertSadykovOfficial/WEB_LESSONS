<?php 
/*
				Основы:
				В UNIX подобных ОС перенос строки осуществляется \n, в WIN \r\n, в MAC \n\r, 
				Но PHP подстравивается и переводит \r\n в \n на лету, правда размеры изменяются 

				Открытие файла:
				int fopen(string $file, string $mode, bool $use_include=false, resource $context)
					 $use_include - сообщает php о том, что если задано относительое имя файла, его следут исктать и в файлах include и require
					 $mode:
					 r
					 r+
					 w
					 w+
					 a
					 a+
					 x
					 x+
					 c
					 c+
					 В конце может быть препись b или t (РЕКОМЕНДУЕТСЯ ПРЕПИСЫВАТЬ, НЕ ВСЕ ОС МОГУТ ОПРЕДЕЛЯТЬ)
					 b - ОТкрывает файл как бинарный
					 t - файл воспринимается как тектовый   

					  $context - Задает контекст потока

			Примеры:
			$f = fopen("/home/user/file.txt", "rt") or die("Ошибка!"); 
			Sf = fopen("http://www.php.net/", "rt") or die ( "Ошибка!"); 
			$f = fopen("ftp://user:pass@example.com/a.txt", "wt") or die("Ошибка!"); 

			--> Конструкция or die(); 
					or - альтернатива ||, но с очень низким приоритетом, ниже,чем у (=), так компьютер видит команду:
					($f = fopen("ftp://user:pass@example.com/a.txt", "wt")) or die();
		
		Допустим надо считать первую строку файла в бинарном режиме и текстовом на раных ОС:
		 Первая строка будет <?php(+ символ переноса строки)
			$f = fopen(__FILE__, "rb"); 
			$f = fopen(__FILE__, "rt"); 
			Тогда ответ в UNIX:
				3C 3F 70 68 70 0A 
				3C 3F 70 68 70 0A 
			Тогда ответ в Win: (Произошла трансляция маркера конца строки)
			3C 3F 70 68 70 OD 0A 
			3C 3F 70 68 70 0A 
*/
/*
			Безымянные временные файлы
			int tmpfile (); 
*/
/*
			Закрытие файла
			
			// false - не удалось, true - истина
			int fclose (int $fp) 

*/

/*
			Блочные Чтение/Запись

			Чтение из файла $f блок из $numbytes символов (возвращетет строку этих символов)
			string fread(int $f, int $numbytes)

			Записывает в файл $f Содержимое строки $st, $length - Максимальная длина на запись в байтах(не обязательно)
			int fwrite (int $f, string $st [, int $length]) 

			!!! При рабое с тектовыми файлами все \n превращаются в разделитель строк вашей ОС
*/

/*
			Построчные Чтение/Запись:

			Читает из файла одну строку, заканчивающуюся символом \n, который тоже считывается и прибавляется в результат
			Если строка занимает больше, чем $length-1 байтов, то возвращает только ее $length-1 символов
			! Аккуратно на Win, т.к идет преодразование \r\n -> \n
			string fgets (int $f [, int $length]) 

			Запись
			int fputs (int $£, string $st) 

*/
/*
			Чтение CSV - ФАЙЛА

			Чтение одной строки из файла, заданного $f и ее разбиение по сиволу $delim
			Поля CSV МОГУТ БЫТЬ ОГРАНИЧЕНЫ КАВЫЧКАМИ, символ кавычек задается в $quote
			Символ экранирование $escape

			Параметры $delim, $quote и $escape - должны быть строкой из 1 символа !!!
			
			Функция вернет список полей или false, если строки кончились
				list fgetcsv( 
											int $f, 
											[int $length = 0,] 						// лучше указывать длину ля повышения скорости
											[string $dalim - ',' ,] 
											[string $quote - '"' ,]
											[string $escape - '\' ]); 

*/

/*
//---		Достижение конца файла

				int feof (int $f); // true

				Пример: (Стоит избегать такой конструкции при чтени всего фалйа - она медлительна, луяшк - fopen)
				$f= fopen("myfile.txt", "r"); 
					while ( ! feof (Sf)) { 
						$st = fgets ($fl); // Tenepb Mbl o6pa0aTblBaeM 04epeDHYJO cTpoKY $st 11 . . . 
					}
						fclose (Sf);
				

//---		Указатель
					Установка указателя на Байт со смещением $offset  (может не сработать, если имеем дело не с локальным файлом, а с http, ftp)

					// успешно - 0 , провал - -1
					int fseak(int $f, in $offset, int $whences SEEK_SET)
						$whences:
							SEEK_SET - Позиция от начала файла
							SEEK_CUR - Позиция относительно текущей	// можно/нужно отрицательные значения
							SEEK_END - Позиция относительно конца		// можно/нужно отрицательные значения

				--Узнать позицию указателя
					int ftell (int $f)  // fseek () вернутся к позиции

				--Усечение файла (файл должен быть открыт в режиме записи)
					// Не забывай передвигать указатель при усечение (fseek)
					bool ftruncate (int $f, int $newsize)  
*/

/*
				Работа с путями 

			--Выделение полного имени файла
				string basmlame(string $path, string $suffix) // suffix - не обязательный параметр, если значение заканчивается на суффикс, то суффикс отбрасывается (полезно для выделения непосредственого имени файла без формата)

			--Выделение каталога 
				$levels - уровень каталога вверх
				string dirname (string $path, int $levels = 1);
					echo dirname ("../file.txt");  // ..
					echo dirname ("file.txt");		 // . - тукущий каталог

					echo dirname("/usr/opt/local/etc/hosts"); 		// 		/usr/opt/local/etc/ 
					echo dirname("/usr/opt/local/etc/hosts", 3); // 		/usr/opt


			--Генератор имени
				Генерируте рандомное имя в котологе dir с префиксом 
				(".")- если нужно содать файл в текущем каталоге
				Если каталога не существует или не указан, то фукция возьмет имя временного каталога
				string tempnum(string $dir, string $prefix) 
				
				Для лучшей уникальности следует еще преписывать что-то , Например:
				$fname = tempnam() . getmypid(); 
				
			--Преобразование относительного пути в абсолютный
				
				string realpath(string $path) 	
				echo realpath("../t.php");			// /home/t.php
				echo realpath(".");							// ВЫВОДИТ МЯ ТЕКУЩЕГО КАТАЛОГА
*/

/*
			Манипулирование целыми файлами
			
		--Копирует файл с именем $src  в файл  именем $dst (при его сущетсвовании выполнится перезапись)
			true - успешно, context будет рассмотрен позже
			bool copy(string $src, string $dst, resource $context) 

		--Переименование
			Если файл $newname сущетвует - генерируется ошибка и возвращается false
			bool rename (string $oldname, string $newname [, resource $context:]);

		--Удаление
			bool unlink (string $filename [, resource $context]);

		--Чтение (Предпочтительно, очень быстро работает)
			Возвращает - массив-список, каждый элемент - строка
			list file (string $filename [, int $flags [, resource $context]]) 
					$flags (можно обьединять побитовым оператором):
					FILE_USE_INCLUDE_PATH - осущствляет поиск в каталогах библиотек PHP. Пути к каталогам содержатся в include_path. Способ получения: ini_get ("include_path"); 
					FILE_IGNORE_NEW_LINES - НЕ добавлять символ переноса строки (\n) в концекаждого эл-та массива
					FILE_SKIP_EMPTY_LINES - Пропускать пустые строки

		--Считать файл в вие одной строки 
			string file_get_contents(
							string $filename, 
							bool $use_include_path = false, 
							resource $context, 
							int $offset = -1, 
							int $maxlen)

				(offset - значение в байтах с которого нужно начинать считывать файл)
				(maxlen - максимальный размер считываемых данных)

		--Записать данные data в файл (трансляция переода строк не осуществляется)
			string file_put_сontents( string $filename, string $data, bool $flags = 0, resource $context);

			$data= file_get_contents("image.gif");
			file_put_contents("newimage.gif", $data); 
			 $flags:
			 FILE_APPEND - Дописать в конец
			 FILE_USE_INCLUDE_PATH - Найти файл в путях поиска библиотк (используемых в include и require) (!!! Аккуратно, чтобы не стереть важные файлы)
			 LOCK_EX - Эксключивная блокировка на время записи 
*/

/*
			Чтение INI-файла
			INI ФАЙЛ - обычный текстовый файл, разеленный на секции с парами ключ=>значение
			
			Вернет ассоциативный массив ключ => значение 
			array parse_ini_file( string $filename, bool $useSections = false, int $mode = INI_SCANNER_NORMAL) 
					Если useSections = false, тогда все секции в файле игнорируются и возвращается все пары ключ => значение
													 = true , тогда вернется двумерный массив. Ключ 1 измерения - имена скций. Ключ 2 - Параметров 
											       -->Доступ:  $array [$sectionName][$paramName]. 
					По умолчанию parse_ini_file стримится нормальзовать содержимое к типам PHP, параметр mode регулирует это
					mode:
					INI_SCANNER_NORMAL - Строки "yes", "true", "on" = true; 0='' ; "false", "off'', "no", "none" = false
					INI_SCANNER_RAW    - Все типы передаются как есть, без нормализации
					INI_SCANNER_TYPED  - Строки "yes", "true", "on" = true; "false", "off'', "no", "none" = false. "null" = null; числовые строки в числа 

			Пример:
			$ini = parse_ini_file("file.ini", true); 
			echo "<pre>"; print_r($ini); echo "</pre>"; 
			echo "Chip: { $ini ['File Settings']['Chip']}"; 
*/	

/*
			ДРУГИЕ ФУКЦИИ

		--БУФЕР И НЕМЕДЛЕННАЯ ЗАПИСЬ
		
		 	Запись в файл производятся сначала в буфер. При достижении значения буфера (обычно) 8Кбайт происходит запись на диск.
		 	Буфер очищается и все повторяется. Для немедленной записи существет функция fflush.(Она неявно вызывается и при закрытии файла)
			Немедленная запись на диск открытого файла $f.
			void fflush (int $f);
			
			Установить буфер для файла (Используй в крайней необходимости, т.к страдает производительнсть):
			int set_file_buffer(int $f, int $size)  // set_file_buffer($f,0); - Отключение буфферизации для немедленной отправки данных
		

		--БЛОКИРОВКИ
			Ркомендательная (advisory locking): Как светофор - используют все по сигналу, но при этом может кто-то и проскочить
			Принудительная (mandatory locking): Как шлагбаум - Никто не может использовать без разрешения.

			bool flock (int $f, int $operation [, int& $wouldblock])

				 $operation:
				 LOCK_SH (или 1) - Разделяемая Блокировка
				 LOCK_EX (или 2) - Исключительная
				 LOCK_UN (или 3) - Снять Блокировку
				 LOCK_NB (или 4) - (прибавить к предидущим) Немедленное выполнение команды, не дожидаяс очереди

				 В случае требования режима без ожидания и блокировка не была успешно установлена в $wouldblock будет записано true

				 При установке flock ( $f, LOCK_EX) файл проваливаетя в функцию и не выходит оттуда до команды LOCK_UN, что не позволяет другим процессам вести запись в файл до его завершения. Остальные процессы в это время ожидают в той же ф-ции flock();

			Пример:
				$file = "file.txt"; 

				// Создаем пустой файл, есди его нет
				fclose(fopen($file, "a+b") ); 
				$f = fopen($file, "r+b") or die("He Mory OTKpblTb файл"); 
				flock($f, LOCK_EX); // Ждем, пока не станем единственными
					// 
					//	Делаем все, что захотим
					//
				fclose ($f) ; // Снимаем блокировку

		--1)!ВНИМАНИЕ, С Блокировками дрпускается всегда много ошибок - важны все мелочи
				При открытии файла нельзя исп деструктинй режим w, нужно использовать мягкий r+,
				Так как удаление файла - это уже ИЗМЕНЕНИЕ содержимого, а идеологически содержимое 
				нельзя менять до установки блокировки (светофоры)!
				Если нужно стеереть файл, все равно не нужно исп w, используй (r+) + (ftruncate())
				Пример:
					$f= fopen(Sfile, "r+") or die("He Mory OTKpblTb ~Ha 3aID1cb!"); 
					flock(Sf, LOCK_EX); //  Ждем, пока не станем единственными
					ftruncate($f, 0); // Очищаем содержимое 

				! Хоть при этом r+ требует обязательног существования файла, так делать нельзя:
					$f= fopen($file, file_exists($file)? "r+b" : "w+b");
					В короткий промежуток меду вызовами file_exists и fopen может втиснуться какой-нибудь
					процесс, что приведет к тому, что файл "уведут из под носа" у скрипта

				 Режим a+ не выход т.к в ОС FreeBSD a+ доступна только дл язаписи в конец файла.
		
		--2)!ВНИМАНИЕ
				 Как мы помним в файл происзоди апись только тогда, когда идет сброс Буфера, поэтму
				 при блокировке Явно прежде следует сбросить буфер, иначе запись моет произойти после 
				 снятия блокировки
				 Пример:
				 		$file = "file.txt"; 

					// Создаем пустой файл, есди его нет
					fclose(fopen($file, "a+b") ); 
					$f = fopen($file, "r+b") or die("He Mory OTKpblTb файл!"); 
					while (true) { 
						flock(Sf, LOCK_EX); //  Ждем, пока не станем единственными
						// ...
						//	Делаем все, что захотим
						// ...
						fflush($f);  					// !СБРАСЫВАЕМ БУФЕР
						flock(Sf, LOCK_UN); 	// Освобождаем файл

						sleep(10);
					}
					fclose($f);

			--3)!ВНИМАНИЕ 
					Чтение (только r и r+)
						file = "file.txt"; 

					// Создаем пустой файл, есди его нет
					fclose(fopen($file, "a+b") ); 
					$f = fopen($file, "r+b") or die("He Mory OTKpblTb файл"); 
					flock($f, LOCK_SH); // Ждем, пока не звершится писатель
						// 
						//	Уверены в том, что  файл никто не пишет
						//
					fclose ($f) ; // Снимаем блокировку


				БЛОКИРОВКИ С ЗАПРЕТОМ ПОДВИСАНИЯ
				 Пока мы ожидаем открытия доступа к файлу, можем поделать что-нибудь полезное (почистить временные файлы и тд) 
				 или сообщить о том, что нужно подождать, пока откроется файл
					$f = fopen("file.txt", "r+b"); 
					while (!flock($f,  LOCK_EX+LOCK_NB)
					{
					echo "Получае доступ к файлу<br>"; 
					sleep(1); // Ждем 1с
					}
					// Работаем с файлом

				ПРИМЕР:
				Счетчик посещения сата при большом трафике, когда могут одноврменно сработать несольо счетчиков
				<?php 
					$file = "counter.dat"; 
					fclose(fopen($file, "a+b")); // Содаем пустой файл
					$f = fopen($file, "r+t"); 	 // Отрываем файл счетчика
					flock($f, LOCK_EX);					 // Блоикруем файл счетчиа
						$count = fread($f, 100); 	 // Считываем первую строку
						$count = $count+1;         // Прибавляем 1 посещение
						ftruncate ($f, 0); 				 // Очищаем файл
						fseek ($f, 0, SEEK_SET);	 // Переходим в начало файла
						fwrite ($f, $count);       // Записываем новое значение
					fclose ($f); 	               // Закрываем файл
					echo $count;								 // Печатаем величичну счетчика
				?>
*/

/*
			РАБОТА С КАТАЛОГАМИ 
			
			С точки зения ОС каталоги - те жесамые файлы, но со специальны имненем

		--Манипулирование каталогами
			
		--Создать каталог с именем name и правами доступа $perms =(0777), 0 обязатеьный, указывает, что это восьмеричная константа
			Успех = true 
			bool mkdir(
								string $name, 
								int $perms = 0777, 
								bool $recursive = false, 
								resource $context);

			mkdir("my_directory", 0770);  - Создает подкаталог в текущем каталоге
			mkdir("/data"); 							- Создает каталог data в корневом каталоге
			
			$recursive - создает недостающие каталоги:
			Если, к примеру, нет каталогов  .ssh и old, вместо 2х вызовов используется: 
			mkdir("/home/igor/.ssh/old", 0700, true) 
			$context - Рассмотерн в другом месте (ГЛАВА 32)

			Обычно пользователь не имеет прав доступа на запись в корневой каталог, поэтому на 
			mkdir("/data"); - Может выдать ошибку (Т.е ситуация как с фалйами)

		--Удалить каталог $name (Есть ограничения файловой системы)
			bool rmdir (string $name [, resource $cantext]) 

		--Сменитьь текущий Каталог
			bool chdir (string $path)

			Пример:
			chdir("/tmp/data");  // Переход по абсолютном пути
			chdir("./something"); // Подкаталг текущего каталога
			или chdir("something"); 
			chd1r(" .. ");     // Переход в родительский каталог
			chdir{"-/data");   // Переход в Home пользователь data - для UNIX
		
		--Полный путь к текущему каталога, либо false, если в доступе отказано
			string getcwd () 


	//-- Работа с записями:
				Каталогиоткрываются как файлы и считываются поштучно/построчно
				
			--Открывает каталог и возвращает его идентификатор
				int opendir (string $path [, resource $context])
				
			--Считывает имя файла/подкаталога
				string readdir (int $handle) //$handle - как раз идентификатор dir
				--> Вместе с именами подкаталогов будут получены и 2 спец элемента:
						"."  - ссылка на текущй каталог
						".." - ссылка на родительский каталог
				Если все файлы считаны, функция вернет false
				Пример:
					$d = opendir("somewhere"); 
					while ( ($e=readdir($d)) !== false) { ... } 

				НО НЕ ТАК! при файле с именем 0 произойдет выход из цикла при выполении
				while ($e = readdir ($d)) { ... } - 
			
			--Закрывает каталог
					void closedir (int $handle);
			
			--Переместить уазатель каталога в начало (потом можно юзать readdir)
				void rewinddir (int $handle) 

	//-- Получение Содержимого Каталога

			Возвращает все ути, подходящие под маску pattern
			list glob (string $pattern [, int $flags])  
				* - Любое число любых символов
				? - Один лбой символ
				glob ( "*. txt") 							 - вернет все txt файлы в каталоге
				glob ( "c: /windows/*. exe") 	 - вернет все exe файлы в каталоге

				$flag - может быть суммой след. констант:
				GLOB_ONLYDIR - Спискок имен каталогов. но н ефайлов
				GLOB_BRACE   - Позволяет задавать альтернативы: glob ( "c: /windows/ {*.exe,*.ini}", GLOB_ BRACE) 
				GLOG_ERR		 - Остановит работу func при ошибке чтения, по умолчанию - ИГНОР
				GLOB_MARK    - Добавляет \ в WIN и / В UNIX к тем элементам списка, которые явл каталогами
				GLOB_NOSORT  - Не сортировать результат по алфавиту (как по умолчанию + скорость)
				GLOB_NOCHECK - Если ничего не найдено, вернет pattern (ненужная хрень)
				GLOB_NOESCAPE- Имена фалйов в UNIX могут иметь служебные символы, если флаг не указан, функция экранирует их, если указан - нет

			glog() Может искать сразу в нескольких каталогах, в соответсвие с маской
*/
?>