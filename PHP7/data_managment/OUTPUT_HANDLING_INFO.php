<?php

			/*
					Output Buffering: ob_

					Перехват выходного потока скрипта нужен для перехвата текста, указанного в echo
					или выведеннного вне тэгов php и направить его в строковую переменную для обаботки.

					Проблемы с отладкой: 
					Все информационные сообщения об ошибках выводятся в буфер, поэтому, если накосячить
					с буфером, то никакой информаци об ошибках можешь не ждать.

			*/

			/*
					Функции перехвата:
					
					ob_start может быть вызвана несколько раз и получается вложенность, при удалении ob_clean,
										управление переходит на ступень выше.

					// Начать перехват (Хранить весь текст в буфер, а не выводть в браузер)
						ob_start();
					
					// Получить текущее содржимое буфера
					// Обеспечивает накопление тектста, выводимого опреатором echo
					// Если буферизация не включена, ернет false
						string ob_get_contents() 
					
					// Очистка буфера выходного потока
						void ob_clean()

					// Завершить буфферизацию потока (при этом все содержимое буфера теряется)
						void ob_end_clean();

					// Немедленно вывести данные  буфер
						void ob_end_flush()

					// Узнать глубину вложенности:
						int ob_get_level() 

			*/

			/*
					Стек Буферов:

						Всегда используется тот буфер, который был активирован последним.

						Проблемы: 
							Буфер, который открыт, должен быть и закрыт.
							Если не закрыть - обнаружить может быть очень трудно.
							Если мы используем функции и исключения, 
							то перед каждым return и в каждом catch 
							мы должны будем прописывать ob_end_clean,
							что захломляе код
						
						Решение:
							Воспринимать буфер как ресурс и завершать его в деструкторе класса.
							Если есть класс Output и в его конструкторе есть открытие буфера,
							то при унитожении Обьекта мы можм закрыть буфер в деструкторе.
						
						Пример вложенноси:

						<?php
								ob_start();
									echo "Попадет в 1 буфер"; 
										ob_start();
											echo "Попадет во 2 буфер"; 
										ob_end_clean(); 
									echo "Попадет в 1 буфер"; 
								ob_end_clean(); 
						?>
						

						Пример решения проблемы закрытия буфера:
						(Класс Output расположен в папке Buffering)

						Недостаток:
							Обьекты лдолжны быть удалены по порядку от самого нижнего, до верхнего,
							так как при удалении более верхнего он затирает ссылку самого нижнего.

						<?php
								spl_autoload_register();

								$h = new \Buffering\Output();  

										echo "Текст какой-то.<br I>"; 
										$formatted= inner(); //  Функция, которая может выводить информацию, которая тоже перехватится
										echo "Конец Перехвата.";
										$text= "{$h->_toString() )<br>~YHl<UMR eepHyna: \"$formatted\""; 

								$h = null; // Уничтожаем обьект и вызываем деструктор.
	
								echo $text; // Печатаем то, то накопил буфер.
								exit();

								function inner () 
								{
										$buf = new \Buffering\Output();
										echo "Этот текст попадет в буффер";
										return "<b>{$buf->_toString()} </b>"; 

										// Деструктор $buf уничтожит буфер, а сам обьект buf  уничтожится сборщиком мусора.
								}
						?>

			*/

			/*

					Обработчик Буферов:
					
					// Создать новый буфер перехвата выходного потока и установить его обработчик 
						 в методе handler, который  буе вызван всякий раз перед  ob_end_flush();
						 Обработчику всегда передатся обязательный параметр - содержимое буфера
						 Вместо имени метода можо передать сылку наметод класа вида:
						 array (&$obj, "methodName") 

						void ob_start([callback $handler] [,int $param]) 
						
						Пример (Удалить все пробелы и переносы строк из html кода - растянуть код в одну строку):

								function ob_linearize($text)
								{
										return preg_replace('/[\r\n\s]+/s',' ',trim($text) ; 
								}
								// Устанавливаем параметры вызожного потока
								ob_start ("ob_linearize");
								// Дальше все, что угодно, функция выполнит свою раюоту
								echo htmlspecialchars(file_get_contents(~FILE~)); 


					// G-Zip сжатие
							Пример в папке G-Zip

						 Современные браузеры поддерживают технологию упакованного контента, 
						 способную ускорить загрузку страницы по сети. 
						 Данные могут быть сжаты примерно в 4-5 раз

						 Проблема:
						 Однажды сжав данные, мы не сможем в них ничего добавитью.
						 Передать информацию бразуре можно, к припмеру, через cookie

						 Принцип работы:

						 1) Серверы генерируют сраницу и упаковывают ее GZip сжатием
						 2) Просходит передача данных
						 3) Брауузер принимат данные и по наличию спец заголовков определяет
						 		метод Архвации. Затем он распаковывает информацию и отображает.

						 Что нужно:
						 1) Проверить поддержку запаковки у Браузера пользователя
						 2) Ввеси заголовки
						 3) Заархивировать тескт и вернуть его в качстве результата

						 Обработчик, занимающийся G-Zip сжатием называется в PHP:
						 	 ob_gzhandler()

						 	 Применяется так:
						 	 ob_start("ob_gzhandler",9); // далее весь текст автоматически будет отправляться упакованным
						
							При этом можно вызывать и сразу несколько обработчиков, они при этом будут как 
							на конвеере, значения ожного передаются другому
			*/


?>