<?php 
/*			

Предворительная настройка сессии на использование ТОЛЬКО cookie
ini_set('session.use_only_cookies', 1);

	Установка cookie
	setcookie(name, value, expire, path, domain, secure, httponly);
	setcookie('username', 'Hannah', time() + 60 * 60 * 24 * 7, '/');
	Удаление cookie
	setcookie('username', 'Hannah', time() - 2592000, '/');  // Метод просрочки

	name 	|	Имя cookie. Это имя ваш сервер будет использовать для доступа к cookie при последующих запросах браузера
	value | Значение cookie или его содержимое. Объем может составлять до 4 Кбайт буквенно-цифрового текста
	expire| (Необязательный.) Время истечения срока действия. Если параметр не установлен, срок действия cookie заканчивается с закрытием браузера
	path 	| (Необязательный.) Путь к cookie на сервере. Если в качестве пути используется прямой слеш (/), cookie доступен для всего домена, 							например для домена www.webserver.com. Если указан подкаталог, cookie доступен только в пределах этого подкаталога. По умолчанию путь 				указывает на текущий каталог, где был установлен cookie, и, как правило, используется именно такая настройка
	domain| (Необязательный.) Интернет-домен, которому принадлежит cookie. Если это webserver.com, то cookie доступен для всего домена 										webserver.com и его поддоменов, например www.webserver.com и для images.webserver.com. Если это images.webserver.com, то cookie 							доступен только для images.webserver.com и его поддоменов, например sub.images.webserver.com, но не для www.webserver.com
	secure| (Необязательный.) Определяет, должен ли cookie использовать безопасное подключение (https://). Если значение параметра установлено в 					TRUE, cookie может быть передан только по безопасному подключению. По умолчанию устанавливается значение FALSE
					FALSE
	httponly| (Необязательный; реализован в PHP, начиная с версии 5.2.0.) Определяет, должен ли cookie использовать протокол HTTP. Если значение 						параметра установлено в TRUE, то такие языки сценариев, как JavaScript, не могут получить доступ к cookie. (Это свойство 											поддерживается не во всех браузерах.) По умолчанию задается значение FALSE
__________________
	Чтение cookie
	(Прочитать куки можно только после перезагрузке страницы)
	if (isset($_COOKIE['username']))    
		$username = $_COOKIE['username']


______________HTTP-аунтификация______________________________________________________________________
		Метод устаревший и не безопасный
		1) Может не сработать так как отключена
		
		php_sapi_name();


 if (isset($_SERVER['PHP_AUTH_USER']) && isset($_SERVER['PHP_AUTH_PW']))  
 	{    
 		if ($_SERVER['PHP_AUTH_USER'] == $username && $_SERVER['PHP_AUTH_PW'] == $password)        
 			echo "Регистрация прошла успешно";   
 		else die("Неверная комбинация имя пользователя — пароль");   // После аунтиф
 	}
 	else {    // ПДо аунтификации выбрасывается окно
 		header('WWW-Authenticate: Basic realm="Restricted Section"');   // Окно аунтификации 
 		header('HTTP/1.0 401 Unauthorized');    											// Если пропустится 1 шаг, будет выведена ошибка
 		die("Пожалуйста, введите имя пользователя и пароль");  
 	} 


----------  Сохранение имени пользователей и паролей
 		-- Одностороннее Шифрвание

 				$token = md5('мой_пароль'); 		// 32 символа
 				$token = sha1('мой_пароль');   //  40 символов (Игрушка дьявола - АНБ) + sha2();
 		
 		-- Предпочтительно
 				$token = hash('ripemd128', 'mypassword'); // 32 символа (ripemd - способ хэширования)
 
 /*	Существуют уже составленные талицы с ответами на некоторые имена, что облегчит взлом
 		Чтобы взлом был более проблимотичным нужно добавлять к данным каке-то известные только
 		нам константы, например
 		$token = hash('ripemd128','ДополнительнаяСтрокаМойПароль');
 			или
 		$token = hash('ripemd128','hqb%$tМойПарольcg*l'); 
 		В таком случае: 
 		На основе лишь тех данных, которые хранятся в базе, 
 		практически невозможно вскрыть хранящиеся пароли, 
 		не имея доступа к вашему PHP-коду. 
 */			


 ?>